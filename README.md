Compilation command:

$ g++ -std=c++20 -I hpp main.cpp cpp/*.cpp -o test.exe

//====================================================

TASK

HW 5. Відпрацювання патернів Observer, Strategy, Factory, та принципів SOLID
Created: 13.05.2025 22:04
Потрібно написати програму, яка зчитує числа з файлу, відфільтровує їх і сповіщає підписників про кожне зчитане число.

Ви маєте вхідний текстовий файл, у якому через пробіл або нову строку вказаний набір чисел:

Copy code
1
2
..
10
Формат командної строки для запуску вашої програми:

Copy code
./number_pipeline <фільтр> <файл>
<фільтр> може бути:
EVEN — залишає тільки парні числа
ODD — залишає тільки непарні числа
GT<n> — залишає тільки числа, що більше за n (наприклад, GT5)
<файл> - імя файлу, у якому знаходяться числа для обробки.
Класи й інтерфейси

Інтерфейс INumberReader та його реалізація: читає всі числа з файлу, повертає std::vector<int>
Інтерфейс INumberFilter та 3 його реалізації: метод bool keep(int)
Інтерфейс INumberObserver та 2 його реалізації: методи void on_number(int),void on_finished()
FilterFactory: за назвою (з командної строки) повертає потрібний фільтр. Варто зробити за принципом FactoryRegistry, як ми зробили на уроці по SOLID - з мапою фабрик/фільтрів. Може не бути абстрактною, адже може нікуди не передаватися (передається готовий INumberFilter по інтерфейсу)
NumberProcessor (може не бути абстрактним, адже він один і він однозначно вирішує, що буде робити наша програма, плюс він нікуди не передається, а використовується напряму у main):
у конструкторі приймає INumberReader&, INumberFilter&, список INumberObserver&
метод run(): читає, фільтрує, викликає on_number() у всіх спостерігачів
Фільтри

Абстрактний клас INumberFilter, з наслідниками для кожного з трьох фільтрів з першого аргументу командної строки.
Обсервери

PrintObserver: виводить число в std::cout
CountObserver: рахує пройдені числа й після завершення виводить загальну кількість
Функція main

Створює потрібний фільтр через фабрику відповідно аргументу командної строки;
Обирає вектор спостерігачів;
Передає все в NumberProcessor і запускає run()
ЯК ВИКОРИСТАТИ ПАТЕРНИ ТА ПРИНЦИПИ?

Observer (спостерігачі): спостерігають, коли число пройшло фільтр, та виконують обробку читання чисел та завершення читання;
Strategy (стратегія): реалізація різних фільтрів (парні, непарні, більше за N) без зміни внутрішнього коду обробщика чисел;
Factory (фабрика): вибір та створення фільтра за назвою з консолі;
SOLID-принципи:
Single Responsibility: кожен клас відповідає лише за одну задачу
Open/Closed: додаємо фільтри та спостерігачів без змін коду самих фільтрів чи NumberProcessor;
Liskov Substitution: можна замінити будь-який клас-нащадок (фільтр чи спостерігач) на його інтерфейс та навпаки..
Interface Segregation: клієнти (користувачі методів інтерфейсів) залежать тільки від тих методів, які вони реально використовують (інтерфейси відповідають тільки за одну задачу).
Dependency Inversion: залежність від абстракцій, а не від конкретних класів. Це значить, що в коді вашого класу не повинно бути рандомних new Class() або інших інстанціацій ваших класів, які не інвертовані (не вказані в сигнатурі методів як аргумент метода).
УВАГА: як завжди, приділяйте увагу можливим помилкам або некоректному вводу від користувача (з аргументів командної строки). Ваша програма не повинна крашитись або взагалі нічого не робити і не виводити на екран. В ідеалі, користувач повинен бути попереджений про будь-який розвиток подій.
